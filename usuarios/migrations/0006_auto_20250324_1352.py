# Generated by Django 5.1.7 on 2025-03-24 16:52

from django.db import migrations, models
import django.db.models.deletion
import uuid
from django.conf import settings
from django.utils import timezone

def asignar_tokens_unicos(apps, schema_editor):
    """Asigna tokens únicos a invitaciones existentes y establece enviada_por"""
    InvitacionCurso = apps.get_model('usuarios', 'InvitacionCurso')
    Usuario = apps.get_model('usuarios', 'Usuario')
    
    # Obtener el primer docente o usuario para asignarlo como enviada_por
    docente = Usuario.objects.filter(rol='docente').first()
    default_user = docente or Usuario.objects.first()
    
    if not default_user:
        print("ADVERTENCIA: No se encontró ningún usuario para asignar como enviada_por")
        return  # No podemos continuar sin un usuario
    
    for invitacion in InvitacionCurso.objects.all():
        invitacion.token = uuid.uuid4()
        if not invitacion.fecha_expiracion:
            invitacion.fecha_expiracion = timezone.now() + timezone.timedelta(days=7)
        
        # Asignar el docente del curso o el usuario por defecto
        if not invitacion.enviada_por_id:
            curso_docente = invitacion.curso.docente
            invitacion.enviada_por = curso_docente if curso_docente else default_user
            
        invitacion.save()


def eliminar_duplicados(apps, schema_editor):
    """Elimina invitaciones duplicadas para mismo curso y email"""
    InvitacionCurso = apps.get_model('usuarios', 'InvitacionCurso')
    from django.db.models import Count
    
    # Identificar duplicados
    duplicados = (
        InvitacionCurso.objects.values('curso_id', 'email')
        .annotate(count=Count('id'))
        .filter(count__gt=1)
    )
    
    print(f"Encontrados {len(duplicados)} grupos de invitaciones duplicadas")
    
    # Para cada grupo de duplicados, mantener solo la invitación más reciente (mayor ID)
    for dup in duplicados:
        curso_id = dup['curso_id']
        email = dup['email']
        
        # Obtener todos los IDs de invitaciones con el mismo curso y email
        invitaciones_ids = list(
            InvitacionCurso.objects.filter(
                curso_id=curso_id, 
                email=email
            ).values_list('id', flat=True)
        )
        
        # Ordenar IDs para mantener el mayor (más reciente)
        invitaciones_ids.sort()
        
        # Mantener el último ID y eliminar el resto
        id_a_mantener = invitaciones_ids.pop()
        
        # Eliminar las invitaciones duplicadas
        if invitaciones_ids:
            print(f"Eliminando {len(invitaciones_ids)} invitaciones duplicadas para curso {curso_id} y email {email}")
            InvitacionCurso.objects.filter(id__in=invitaciones_ids).delete()
    
    # Verificar que no quedan duplicados
    duplicados_restantes = (
        InvitacionCurso.objects.values('curso_id', 'email')
        .annotate(count=Count('id'))
        .filter(count__gt=1)
    )
    
    if duplicados_restantes:
        print(f"ADVERTENCIA: Aún quedan {len(duplicados_restantes)} grupos de invitaciones duplicadas")


class Migration(migrations.Migration):

    dependencies = [
        ('usuarios', '0005_alter_usuario_anos_experiencia'),
    ]

    operations = [
        # Eliminar campo código de invitación si existe
        migrations.RemoveField(
            model_name='invitacioncurso',
            name='codigo_invitacion',
        ),
        
        # Agregar token como campo UUID
        migrations.AddField(
            model_name='invitacioncurso',
            name='token',
            field=models.UUIDField(default=uuid.uuid4, editable=False, null=True),
        ),
        
        # Agregar campo enviada_por como ForeignKey a Usuario (inicialmente null)
        migrations.AddField(
            model_name='invitacioncurso',
            name='enviada_por',
            field=models.ForeignKey(null=True, on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL, related_name='invitaciones_enviadas'),
        ),
        
        # Asignar tokens únicos y establecer enviada_por para registros existentes
        migrations.RunPython(asignar_tokens_unicos),
        
        # Eliminar duplicados antes de agregar la restricción única
        migrations.RunPython(eliminar_duplicados),
        
        # Hacer token obligatorio y único después de asignar valores
        migrations.AlterField(
            model_name='invitacioncurso',
            name='token',
            field=models.UUIDField(default=uuid.uuid4, editable=False, unique=True),
        ),
        
        # Hacer enviada_por obligatorio después de asignar valores
        migrations.AlterField(
            model_name='invitacioncurso',
            name='enviada_por',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL, related_name='invitaciones_enviadas'),
        ),
        
        # Constraint para curso-email único
        migrations.AddConstraint(
            model_name='invitacioncurso',
            constraint=models.UniqueConstraint(fields=('curso', 'email'), name='unique_curso_email'),
        ),
        
        # Actualizar opciones del modelo
        migrations.AlterModelOptions(
            name='invitacioncurso',
            options={'verbose_name': 'Invitación a Curso', 'verbose_name_plural': 'Invitaciones a Cursos'},
        ),
    ]
